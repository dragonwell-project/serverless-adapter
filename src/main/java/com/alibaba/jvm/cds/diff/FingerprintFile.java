package com.alibaba.jvm.cds.diff;

import com.alibaba.jvm.util.Utils;

import java.io.*;
import java.util.*;

public class FingerprintFile {
    private static final String FILE_NAME = "cds_fingerprint.lst";
    private static final String HEADER = "#This file is auto-generated by com.alibaba.jvm.cds.diff.Fingerprint";
    private static final String META_TOTAL = "#Total:";
    private static final String EMPTY_FIELD = "-";
    static final String OUTER_SEP = ",";
    static final String INNER_SEP = " ";
    private List<ClassDesc> classDescList = new ArrayList<>();
    private List<NotFoundClassDesc> notFoundClassList = new ArrayList<>();
    private static final String[] ACCEPT_SOURCE_SCHEMA = new String[]{"file:", "jar:file:"};
    private int total = 0;

    public void addClassRecord(String className, String originSource, String fingerprint, String id, String superId, List<String> interfaceIds) throws Exception {
        if (accept(originSource)) {
            ClassDesc cd = new ClassDesc();
            cd.name = className;
            cd.fingerprint = fingerprint;
            cd.id = id;
            cd.superId = superId;
            cd.interfaceIds = interfaceIds;
            cd.ownerFile = getOwnerFile(originSource);
            classDescList.add(cd);
        }
        total++;
    }

    private String getOwnerFile(String originSource) {
        // a fat jar url like this: !/BOOT-INF/lib/httpclient-4.5.13.jar!/
        // what we want to get is the file name ,not the whole file.
        // so need remove ! is safe
        String str = originSource.replace("!", "");
        if (str.endsWith("/")) {
            str = str.substring(0, str.length() - 1);
        }
        int index = str.lastIndexOf(File.separatorChar);
        return index == -1 ? str : str.substring(index + 1);
    }

    private boolean accept(String originSource) {
        return Arrays.stream(ACCEPT_SOURCE_SCHEMA).filter((s) -> originSource.startsWith(s)).findAny().isPresent();
    }

    public void addNotFoundClassRecord(String className) {
        NotFoundClassDesc nfcd = new NotFoundClassDesc();
        nfcd.name = className;
        notFoundClassList.add(nfcd);
    }

    public String write(String dir) throws IOException {
        String dest = dir + File.separator + FILE_NAME;
        try (BufferedWriter bw = new BufferedWriter(new FileWriter(dest))) {
            writeHeader(bw);
            writeClass(bw, classDescList);
            writeNotFound(bw, notFoundClassList);
        }
        return dest;
    }

    private void writeNotFound(BufferedWriter bw, List<NotFoundClassDesc> notFoundClassList) throws IOException {
        for (NotFoundClassDesc cfcd : notFoundClassList) {
            bw.write(cfcd.format());
            bw.newLine();
        }
    }

    private void writeHeader(BufferedWriter bw) throws IOException {
        bw.write(HEADER);
        bw.newLine();
        bw.write(META_TOTAL + total);
        bw.newLine();
    }

    public List<ClassDesc> getClassDescList() {
        return classDescList;
    }

    public List<NotFoundClassDesc> getNotFoundClassList() {
        return notFoundClassList;
    }

    public void read(String dir) throws IOException {
        List<String> lines = Utils.readPlainText(dir + File.separator + FILE_NAME);
        for (String line : lines) {
            if (line.startsWith("#")) {
                if (line.startsWith(META_TOTAL)) {
                    total = Integer.parseInt(line.split(":")[1]);
                }
                continue;
            }
            if (ClassDesc.accept(line)) {
                classDescList.add(ClassDesc.parse(line));
            } else if (NotFoundClassDesc.accept(line)) {
                notFoundClassList.add(NotFoundClassDesc.parse(line));
            }
        }
    }

    public int getTotal() {
        return total;
    }

    private void writeClass(BufferedWriter bw, List<ClassDesc> classDescList) throws IOException {
        for (ClassDesc cd : classDescList) {
            bw.write(cd.format());
            bw.newLine();
        }
    }

    public static class ClassDesc {
        String name;
        String fingerprint;
        String id;
        String superId;
        List<String> interfaceIds;
        String ownerFile;
        static final String TYPE = "class";

        public static ClassDesc parse(String line) {
            String[] s = line.split(OUTER_SEP);
            ClassDesc cc = new ClassDesc();
            int i = 1; // skip the first TYPE
            cc.id = s[i++];
            cc.name = s[i++];
            cc.superId = parseConvert(s[i++]);
            cc.interfaceIds = parseInterfaces(s[i++]);
            cc.fingerprint = s[i++];
            cc.ownerFile = s[i++];
            return cc;
        }

        private static List<String> parseInterfaces(String s) {
            if (EMPTY_FIELD.equals(s)) {
                return Collections.emptyList();
            } else {
                return List.of(s.split(INNER_SEP));
            }
        }

        public String format() {
            return String.join(OUTER_SEP, TYPE, id, name, formatConvert(superId),
                    isNotEmpty(interfaceIds) ? String.join(INNER_SEP, interfaceIds) : EMPTY_FIELD, fingerprint, ownerFile);
        }

        private boolean isNotEmpty(List<?> list) {
            return list != null && !list.isEmpty();
        }

        public static boolean accept(String line) {
            return line.startsWith(TYPE);
        }
    }

    public static class NotFoundClassDesc {
        String name;
        static final String TYPE = "notfound";

        public static boolean accept(String line) {
            return line.startsWith(TYPE);
        }

        public static NotFoundClassDesc parse(String line) {
            String[] s = line.split(OUTER_SEP);
            NotFoundClassDesc nfcd = new NotFoundClassDesc();
            int i = 1; // skip the first TYPE
            nfcd.name = s[i++];
            return nfcd;
        }

        public String format() {
            return String.join(OUTER_SEP, TYPE, name);
        }
    }

    private static String formatConvert(String str) {
        return (null == str || "".equals(str)) ? EMPTY_FIELD : str;
    }

    private static String parseConvert(String str) {
        return EMPTY_FIELD.equals(str) ? null : str;
    }

}
